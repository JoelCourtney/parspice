package parspice.socketManager;

import parspice.sender.Sender;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

/**
 * A threadable class that sends a list of inputs to a worker process,
 * and listens for responses.
 *
 * It aggregates the responses into a list, which is later combined with the
 * lists generated by other workers.
 *
 * @param <I> The type serialized to send to the worker.
 * @param <O> The type deserialized from the worker.
 */
public class IOSocketManager<I,O> extends SocketManager<O> {
    private final Sender<I> inputSender;
    private final Sender<O> outputSender;
    private final List<I> inputs;

    /**
     * Creates an instance of InputOutputSocketManager.
     *
     * @param serverSocket a pre-made socket to interact with.
     * @param inputs the list of inputs to send to the worker.
     * @param inputSender a serializer for sending the inputs to the worker.
     * @param outputSender a deserializer for receiving the outputs from the worker.
     * @param workerIndex the unique index of the worker, used for error reporting.
     */
    public IOSocketManager(ServerSocket serverSocket, List<I> inputs, Sender<I> inputSender, Sender<O> outputSender, int workerIndex) {
        super(serverSocket, workerIndex, inputs.size());
        this.inputs = inputs;
        this.inputSender = inputSender;
        this.outputSender = outputSender;
    }

    /**
     * Sends the inputs and listens for the responses.
     *
     * This function is inefficient, but it seems like it shouldn't
     * need to be. Note the oos.flush() in between the for loops. Without that,
     * the responses stop being received and I don't know why. If there was a way
     * to remove that line, it would be faster.
     */
    @Override
    protected void sendAndReceive() {
        try {
            ObjectInputStream ois = getInputStream();
            ObjectOutputStream oos = getOutputStream();
            for (I input : inputs) {
                inputSender.write(input, oos);
            }
            oos.flush();
            for (int i = 0; i < inputs.size(); i++) {
                outputs.add(outputSender.read(ois));
            }
            ois.close();
            oos.close();
        } catch (IOException e) {
            System.out.println("Socket Manager " + workerIndex + " failed after " + outputs.size());
            e.printStackTrace();
        }
    }
}
