"""
Objects generated by ParSPICE.g4 grammar.
"""


class FunctionDecl:
    """
    Represents a function declaration in CSPICE.java
    """
    def __init__(self, name, classification, return_type, args, throws):
        self.name = name
        self.classification = classification
        self.return_type = return_type
        self.args = args
        self.throws = throws

    def __str__(self):
        return str(self.return_type) + " " + self.name

    def upper_name(self):
        return self.name[0].upper() + self.name[1:]
    def lower_name(self):
        return self.name.lower()


class Argument:
    """
    Represents a single argument with name and data type.
    """
    def __init__(self, name, data_type):
        self.name = name
        self.data_type = data_type

    def __str__(self):
        return str(self.data_type) + " " + self.name

    def set_io(self, io):
        self.io = io


class DataType:
    """
    Data types used by CSPICE.
    Arrays are represented with the array_depth variable.
    """
    VOID = 0
    INT = 1
    DOUBLE = 2
    BOOLEAN = 3
    STRING = 4
    GFSEARCHUTILS = 5
    GFSCALARQUANTITY = 6

    def __init__(self, base_type, array_depth):
        self.base_type = base_type
        self.array_depth = array_depth

    def __str__(self):
        result = ""
        if self.base_type == DataType.VOID:
            result = "void"
        elif self.base_type == DataType.INT:
            result = "int"
        elif self.base_type == DataType.DOUBLE:
            result = "double"
        elif self.base_type == DataType.BOOLEAN:
            result = "boolean"
        elif self.base_type == DataType.STRING:
            result = "String"
        elif self.base_type == DataType.GFSEARCHUTILS:
            result = "GFSearchUtils"
        elif self.base_type == DataType.GFSCALARQUANTITY:
            result = "GFScalarQuantity"
        else:
            raise ValueError("Base type not recognized: " + str(self.base_type))
        return result + "[]"*self.array_depth
    
    def base_to_str(self):
        if self.base_type == DataType.VOID:
            return "void"
        elif self.base_type == DataType.INT:
            return "int"
        elif self.base_type == DataType.DOUBLE:
            return "double"
        elif self.base_type == DataType.BOOLEAN:
            return "boolean"
        elif self.base_type == DataType.STRING:
            return "String"
        elif self.base_type == DataType.GFSEARCHUTILS:
            return "GFSearchUtils"
        elif self.base_type == DataType.GFSCALARQUANTITY:
            return "GFScalarQuantity"
        else:
            raise ValueError("Base type not recognized: " + str(self.base_type))

    def object_str(self):
        return str(self).replace('int', 'Integer').replace('double', 'Double').replace('boolean', 'Boolean')
    def base_object_str(self):
        return self.base_to_str().replace('int', 'Integer').replace('double', 'Double').replace('boolean', 'Boolean')

    def proto_str(self):
        if self.array_depth in [0,1]:
            ty = ''
            if self.base_type == DataType.VOID:
                return None
            elif self.base_type == DataType.INT:
                ty = 'int32'
            elif self.base_type == DataType.BOOLEAN:
                ty = 'bool'
            elif self.base_type == DataType.GFSEARCHUTILS:
                return None
            elif self.base_type == DataType.GFSCALARQUANTITY:
                return None
            else:
                ty = self.base_to_str().lower()
            if self.array_depth == 1:
                ty = "repeated " + ty
            return ty
        elif self.array_depth == 2:
            if self.base_type == DataType.DOUBLE:
                return 'repeated RepeatedDouble'
            elif self.base_type == DataType.INT:
                return 'repeated RepeatedInt'
            else:
                return None


class Classification:
    NORMAL = 0
    CONSTANT = 1
    GLOBAL_STATE_MODIFIER = 2
    TASK_STATEFUL = 3

    @staticmethod
    def from_str(s):
        if s == 'NORMAL': return Classification.NORMAL
        elif s == 'CONSTANT': return Classification.CONSTANT
        elif s == 'GLOBAL_STATE_MODIFIER': return Classification.GLOBAL_STATE_MODIFIER
        elif s == 'TASK_STATEFUL': return Classification.TASK_STATEFUL
        else: return None


class IO:
    INPUT = 0
    OUTPUT = 1
    BOTH = 2

    @staticmethod
    def from_str(s):
        map = {'i': IO.INPUT, 'o': IO.OUTPUT, 'io': IO.BOTH}
        return [map[v] for v in s.split(',') if len(v) != 0]